//
//  PhotoCollectionInteractor.swift
//  STPhotoCollection-iOS
//
//  Created by Dimitri Strauneanu on 08/08/2017.
//  Copyright (c) 2017 Streetography. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import STPhotoCore

protocol PhotoCollectionBusinessLogic {
    func shouldFetchEntityDetails()
    
    func shouldFetchNextEntityPhotos()
    
    func shouldPresentPhoto(request: PhotoCollection.PresentPhoto.Request)
    
    func shouldDownloadPhoto(request: PhotoCollection.DownloadPhoto.Request)
    
    func setModel(model: PhotoCollection.Model)
    func setPhotoItemSize(size: CGSize)
}

protocol PhotoCollectionDataStore {
    var photos: [STPhoto] { get set }
    
    var model: PhotoCollection.Model? { get set }
    
    var photoItemSize: CGSize { get set }
}

class PhotoCollectionInteractor: PhotoCollectionBusinessLogic, PhotoCollectionDataStore {
    var presenter: PhotoCollectionPresentationLogic?
    var worker: PhotoCollectionWorker?
    
    var photos: [STPhoto] = []
    
    var model: PhotoCollection.Model?
    
    var photoItemSize: CGSize = CGSize.zero
    
    var photosPaginationModel: PhotoCollection.PaginationModel
    
    private let photosMinimumThreshold: Int = 20
    
    private func photoForId(photoId: String?) -> STPhoto? {
        return self.photos.filter({ $0.id == photoId }).first
    }
    
    func setModel(model: PhotoCollection.Model) {
        self.model = model
    }
    
    func setPhotoItemSize(size: CGSize) {
        self.photoItemSize = size
    }
    
    init() {
        self.photosPaginationModel = PhotoCollection.PaginationModel(isFetchingItems: false, noMoreItems: false, noItems: false, limit: 30, currentPage: 0)
        self.worker = PhotoCollectionWorker(delegate: self)
    }
}

// MARK: - Business logic

extension PhotoCollectionInteractor {
    func shouldFetchEntityDetails() {
        self.presentEntityDetails()
        self.fetchGeoEntity()
    }
    
    private func fetchGeoEntity() {
        if let model = self.model {
            self.presenter?.presentWillFetchEntityDetails()
            self.worker?.fetchGeoEntity(location: model.entityModel.location, entityLevel: model.entityModel.level)
        }
    }
    
    private func shouldFetchEntityPhotos() {        
        if self.photosPaginationModel.noItems || self.photosPaginationModel.noMoreItems || self.photosPaginationModel.isFetchingItems {
            return
        }
        
        self.shouldFetchPhotos()
    }
    
    func shouldFetchNextEntityPhotos() {
        self.shouldFetchEntityPhotos()
    }
    
    private func shouldFetchPhotos() {
        self.photosPaginationModel.isFetchingItems = true
        self.presenter?.presentWillFetchPhotos()
        
        if let workerModel = self.fetchPhotosWorkerModel() {
            self.worker?.fetchPhotos(model: workerModel)
        }
    }
    
    private func fetchPhotosWorkerModel() -> PhotoCollectionWorker.FetchPhotosModel? {
        guard let model = self.model else {
            return nil
        }
        guard let geoEntity = model.geoEntity else {
            return nil
        }
        let skip = self.photosPaginationModel.limit * self.photosPaginationModel.currentPage
        return PhotoCollectionWorker.FetchPhotosModel(skip: skip, limit: self.photosPaginationModel.limit, geoEntity: geoEntity, entityModel: model.entityModel, filterModel: model.filterModel)
    }
    
    func shouldPresentPhoto(request: PhotoCollection.PresentPhoto.Request) {
        if let photo = self.photoForId(photoId: request.photoId) {
            self.presentPhotoDetailFor(photo: photo)
        }
    }
        
    func shouldDownloadPhoto(request: PhotoCollection.DownloadPhoto.Request) {
        if request.displayedPhoto?.imageUrl != nil {
            self.worker?.downloadPhotoFor(displayedPhoto: request.displayedPhoto)
        }
    }
}

// MARK: - PhotoCollectionWorkerDelegate

extension PhotoCollectionInteractor: PhotoCollectionWorkerDelegate {
    func successDidGetGeoEntity(geoEntity: GeoEntity?) {
        if let entity = geoEntity {
            self.model?.geoEntity = entity
            self.presentEntityDetails()
            self.shouldFetchEntityPhotos()
        } else {
            self.presenter?.presentNoPhotos()
            self.presenter?.presentDidFetchEntityDetails()
            self.photosPaginationModel.noItems = true
        }
    }
    
    func failureDidGetGeoEntity(error: OperationError) {
        self.presenter?.presentNoPhotos()
        self.presenter?.presentDidFetchEntityDetails()
        self.photosPaginationModel.noItems = true
    }
    
    func didFetchPhotos(photos: [STPhoto]) {
        self.photos.append(contentsOf: photos)
        self.presentPhotos(photos: photos)
        self.photosPaginationModel.incrementCurrentPage()
        self.photosPaginationModel.isFetchingItems = false
        
        self.verifyLastPageOfPhotos(photoCount: photos.count)
    }
    
    private func verifyLastPageOfPhotos(photoCount: Int) {
        guard photoCount < self.photosPaginationModel.limit else {
            return
        }
        self.photosPaginationModel.noMoreItems = true
        self.presenter?.presentDidFetchPhotos()
        self.presentEmptyStateIfNeeded(photoCount: photoCount)
    }
    
    private func presentEmptyStateIfNeeded(photoCount: Int) {
        if self.photos.count == 0 && photoCount == 0 {
            self.presenter?.presentNoMorePhotos()
        }
    }
    
    func successDidFetchPhotoImage(displayedPhoto: PhotoCollection.DisplayedPhoto?, image: UIImage?) {
        displayedPhoto?.setImage(image: image)
    }
    
    func failureDidFetchPhotoImage(displayedPhoto: PhotoCollection.DisplayedPhoto?, error: OperationError) {
        
    }
}

// MARK: - Presentation logic (VIP)

extension PhotoCollectionInteractor {
    private func presentPhotos(photos: [STPhoto]) {
        let response = PhotoCollection.FetchPhotos.Response(photos: photos, photoSize: self.photoItemSize)
        self.presenter?.presentFetchedPhotos(response: response)
    }
    
    private func presentPhotoDetailFor(photo: STPhoto) {
        let response = PhotoCollection.PresentPhotoDetail.Response(photo: photo)
        self.presenter?.presentPhotoDetailView(response: response)
    }
    
    private func presentNoPhotosIfNeeded() {
        if self.photosPaginationModel.noItems {
            self.presenter?.presentNoMorePhotos()
        }
    }

    private func presentEntityDetails() {
        if let model = self.model {
            let response = PhotoCollection.PresentEntityDetails.Response(name: model.geoEntity?.name, level: model.entityModel.level)
            self.presenter?.presentEntityDetails(response: response)
        }
    }
}
