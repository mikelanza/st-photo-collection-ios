//
//  STPhotoCollectionInteractor.swift
//  STPhotoCollection-iOS
//
//  Created by Dimitri Strauneanu on 08/08/2017.
//  Copyright (c) 2017 Streetography. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import STPhotoCore

protocol STPhotoCollectionBusinessLogic {
    func shouldFetchEntityDetails()
    
    func shouldFetchNextEntityPhotos()
    
    func shouldPresentPhoto(request: STPhotoCollection.PresentPhoto.Request)
    
    func shouldFetchImageForPhoto(request: STPhotoCollection.FetchImage.Request)
    
    func setModel(model: STPhotoCollection.Model)
    func setPhotoItemSize(size: CGSize)
}

protocol STPhotoCollectionDataStore {
    var photos: [STPhoto] { get set }
    
    var model: STPhotoCollection.Model? { get set }
    
    var photoItemSize: CGSize { get set }
}

class STPhotoCollectionInteractor: STPhotoCollectionBusinessLogic, STPhotoCollectionDataStore {
    var presenter: STPhotoCollectionPresentationLogic?
    var worker: STPhotoCollectionWorker?
    
    var photos: [STPhoto] = []
    
    var model: STPhotoCollection.Model?
    
    var photoItemSize: CGSize = CGSize.zero
    
    var photosPaginationModel: STPhotoCollection.PaginationModel
    
    private let photosMinimumThreshold: Int = 20
    
    private func photoForId(photoId: String?) -> STPhoto? {
        return self.photos.filter({ $0.id == photoId }).first
    }
    
    func setModel(model: STPhotoCollection.Model) {
        self.model = model
    }
    
    func setPhotoItemSize(size: CGSize) {
        self.photoItemSize = size
    }
    
    init() {
        self.photosPaginationModel = STPhotoCollection.PaginationModel(isFetchingItems: false, noMoreItems: false, noItems: false, limit: 30, currentPage: 0)
        self.worker = STPhotoCollectionWorker(delegate: self)
    }
}

// MARK: - Business logic

extension STPhotoCollectionInteractor {
    func shouldFetchEntityDetails() {
        self.presentEntityDetails()
        self.fetchGeoEntity()
    }
    
    private func fetchGeoEntity() {
        if let model = self.model {
            self.presenter?.presentWillFetchEntityDetails()
            self.worker?.fetchGeoEntity(location: model.entityModel.location, entityLevel: model.entityModel.level)
        }
    }
    
    private func shouldFetchEntityPhotos() {        
        if self.photosPaginationModel.noItems || self.photosPaginationModel.noMoreItems || self.photosPaginationModel.isFetchingItems {
            return
        }
        
        self.shouldFetchPhotos()
    }
    
    func shouldFetchNextEntityPhotos() {
        self.shouldFetchEntityPhotos()
    }
    
    private func shouldFetchPhotos() {
        self.photosPaginationModel.isFetchingItems = true
        self.presenter?.presentWillFetchPhotos()
        
        if let workerModel = self.fetchPhotosWorkerModel() {
            self.worker?.fetchPhotos(model: workerModel)
        }
    }
    
    private func fetchPhotosWorkerModel() -> STPhotoCollectionWorker.FetchPhotosModel? {
        guard let model = self.model else {
            return nil
        }
        guard let geoEntity = model.geoEntity else {
            return nil
        }
        let skip = self.photosPaginationModel.limit * self.photosPaginationModel.currentPage
        return STPhotoCollectionWorker.FetchPhotosModel(skip: skip, limit: self.photosPaginationModel.limit, geoEntity: geoEntity, entityModel: model.entityModel, filterModel: model.filterModel)
    }
    
    func shouldPresentPhoto(request: STPhotoCollection.PresentPhoto.Request) {
        if let photo = self.photoForId(photoId: request.photoId) {
            self.presentPhotoDetailFor(photo: photo)
        }
    }
}

// MARK: - PhotoCollectionWorkerDelegate

extension STPhotoCollectionInteractor: STPhotoCollectionWorkerDelegate {
    func successDidGetGeoEntity(geoEntity: GeoEntity?) {
        if let entity = geoEntity {
            self.model?.geoEntity = entity
            self.presentEntityDetails()
            self.shouldFetchEntityPhotos()
        } else {
            self.presenter?.presentNoPhotos()
            self.presenter?.presentDidFetchEntityDetails()
            self.photosPaginationModel.noItems = true
        }
    }
    
    func failureDidGetGeoEntity(error: OperationError) {
        self.presenter?.presentNoPhotos()
        self.presenter?.presentDidFetchEntityDetails()
        self.photosPaginationModel.noItems = true
    }
    
    func didFetchPhotos(photos: [STPhoto]) {
        self.photos.append(contentsOf: photos)
        self.presentPhotos(photos: photos)
        self.photosPaginationModel.incrementCurrentPage()
        self.photosPaginationModel.isFetchingItems = false
        
        self.verifyLastPageOfPhotos(photoCount: photos.count)
    }
    
    func failureDidFetchPhotos(error: OperationError) {
        self.presenter?.presentDidFetchPhotos()
    }
    
    private func verifyLastPageOfPhotos(photoCount: Int) {
        guard photoCount < self.photosPaginationModel.limit else {
            return
        }
        self.photosPaginationModel.noMoreItems = true
        self.presenter?.presentDidFetchPhotos()
        self.presentEmptyStateIfNeeded(photoCount: photoCount)
    }
    
    private func presentEmptyStateIfNeeded(photoCount: Int) {
        if self.photos.count == 0 && photoCount == 0 {
            self.presenter?.presentNoMorePhotos()
        }
    }
}

// MARK: - Fetch image

extension STPhotoCollectionInteractor {
    func shouldFetchImageForPhoto(request: STPhotoCollection.FetchImage.Request) {
        let image = request.displayedPhoto.image
        let imageUrl = request.displayedPhoto.imageUrl
        let isLoadingImage = request.displayedPhoto.isLoadingImage
        
        guard isLoadingImage == false else { return }
        
        if image == nil && imageUrl != nil {
            self.presenter?.presentWillFetchImage(response: STPhotoCollection.FetchImage.Response(displayedPhoto: request.displayedPhoto, image: nil))
            self.worker?.fetchImageFor(displayedPhoto: request.displayedPhoto)
        } else if image == nil && imageUrl == nil {
            self.presenter?.presentImage(response: STPhotoCollection.FetchImage.Response(displayedPhoto: request.displayedPhoto, image: UIImage()))
        }
    }
    
    func successDidFetchPhotoImage(displayedPhoto: STPhotoCollection.DisplayedPhoto, image: UIImage?) {
        self.presenter?.presentDidFetchImage(response: STPhotoCollection.FetchImage.Response(displayedPhoto: displayedPhoto, image: nil))
        self.presenter?.presentImage(response: STPhotoCollection.FetchImage.Response(displayedPhoto: displayedPhoto, image: image))
    }
    
    func failureDidFetchPhotoImage(displayedPhoto: STPhotoCollection.DisplayedPhoto, error: OperationError) {
        self.presenter?.presentDidFetchImage(response: STPhotoCollection.FetchImage.Response(displayedPhoto: displayedPhoto, image: nil))
        self.presenter?.presentImage(response: STPhotoCollection.FetchImage.Response(displayedPhoto: displayedPhoto, image: UIImage()))
    }
}

// MARK: - Presentation logic (VIP)

extension STPhotoCollectionInteractor {
    private func presentPhotos(photos: [STPhoto]) {
        let response = STPhotoCollection.FetchPhotos.Response(photos: photos, photoSize: self.photoItemSize)
        self.presenter?.presentFetchedPhotos(response: response)
    }
    
    private func presentPhotoDetailFor(photo: STPhoto) {
        let response = STPhotoCollection.PresentPhotoDetail.Response(photo: photo)
        self.presenter?.presentPhotoDetailView(response: response)
    }
    
    private func presentNoPhotosIfNeeded() {
        if self.photosPaginationModel.noItems {
            self.presenter?.presentNoMorePhotos()
        }
    }

    private func presentEntityDetails() {
        if let model = self.model {
            let response = STPhotoCollection.PresentEntityDetails.Response(name: model.geoEntity?.name, level: model.entityModel.level)
            self.presenter?.presentEntityDetails(response: response)
        }
    }
}
